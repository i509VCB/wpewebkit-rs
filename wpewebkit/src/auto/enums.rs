// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAuthenticationScheme")]
pub enum AuthenticationScheme {
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_DEFAULT")]
    Default,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC")]
    HttpBasic,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST")]
    HttpDigest,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM")]
    HtmlForm,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_NTLM")]
    Ntlm,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE")]
    Negotiate,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED")]
    ClientCertificateRequested,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED")]
    ServerTrustEvaluationRequested,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_PIN_REQUESTED")]
    ClientCertificatePinRequested,
    #[doc(alias = "WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN")]
    Unknown,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl fmt::Display for AuthenticationScheme {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AuthenticationScheme::{}", match *self {
            Self::Default => "Default",
            Self::HttpBasic => "HttpBasic",
            Self::HttpDigest => "HttpDigest",
            Self::HtmlForm => "HtmlForm",
            Self::Ntlm => "Ntlm",
            Self::Negotiate => "Negotiate",
            Self::ClientCertificateRequested => "ClientCertificateRequested",
            Self::ServerTrustEvaluationRequested => "ServerTrustEvaluationRequested",
            Self::ClientCertificatePinRequested => "ClientCertificatePinRequested",
            Self::Unknown => "Unknown",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl IntoGlib for AuthenticationScheme {
    type GlibType = ffi::WebKitAuthenticationScheme;

    fn into_glib(self) -> ffi::WebKitAuthenticationScheme {
        match self {
            Self::Default => ffi::WEBKIT_AUTHENTICATION_SCHEME_DEFAULT,
            Self::HttpBasic => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC,
            Self::HttpDigest => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST,
            Self::HtmlForm => ffi::WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM,
            Self::Ntlm => ffi::WEBKIT_AUTHENTICATION_SCHEME_NTLM,
            Self::Negotiate => ffi::WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE,
            Self::ClientCertificateRequested => ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED,
            Self::ServerTrustEvaluationRequested => ffi::WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED,
            Self::ClientCertificatePinRequested => ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_PIN_REQUESTED,
            Self::Unknown => ffi::WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAuthenticationScheme> for AuthenticationScheme {
    unsafe fn from_glib(value: ffi::WebKitAuthenticationScheme) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_AUTHENTICATION_SCHEME_DEFAULT => Self::Default,
            ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_BASIC => Self::HttpBasic,
            ffi::WEBKIT_AUTHENTICATION_SCHEME_HTTP_DIGEST => Self::HttpDigest,
            ffi::WEBKIT_AUTHENTICATION_SCHEME_HTML_FORM => Self::HtmlForm,
            ffi::WEBKIT_AUTHENTICATION_SCHEME_NTLM => Self::Ntlm,
            ffi::WEBKIT_AUTHENTICATION_SCHEME_NEGOTIATE => Self::Negotiate,
            ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_REQUESTED => Self::ClientCertificateRequested,
            ffi::WEBKIT_AUTHENTICATION_SCHEME_SERVER_TRUST_EVALUATION_REQUESTED => Self::ServerTrustEvaluationRequested,
            ffi::WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_PIN_REQUESTED => Self::ClientCertificatePinRequested,
            ffi::WEBKIT_AUTHENTICATION_SCHEME_UNKNOWN => Self::Unknown,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl StaticType for AuthenticationScheme {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_authentication_scheme_get_type()) }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl glib::value::ValueType for AuthenticationScheme {
    type Type = Self;
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
unsafe impl<'a> FromValue<'a> for AuthenticationScheme {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl ToValue for AuthenticationScheme {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAutomationBrowsingContextPresentation")]
pub enum AutomationBrowsingContextPresentation {
    #[doc(alias = "WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_WINDOW")]
    Window,
    #[doc(alias = "WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_TAB")]
    Tab,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl fmt::Display for AutomationBrowsingContextPresentation {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AutomationBrowsingContextPresentation::{}", match *self {
            Self::Window => "Window",
            Self::Tab => "Tab",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl IntoGlib for AutomationBrowsingContextPresentation {
    type GlibType = ffi::WebKitAutomationBrowsingContextPresentation;

    fn into_glib(self) -> ffi::WebKitAutomationBrowsingContextPresentation {
        match self {
            Self::Window => ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_WINDOW,
            Self::Tab => ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_TAB,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAutomationBrowsingContextPresentation> for AutomationBrowsingContextPresentation {
    unsafe fn from_glib(value: ffi::WebKitAutomationBrowsingContextPresentation) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_WINDOW => Self::Window,
            ffi::WEBKIT_AUTOMATION_BROWSING_CONTEXT_PRESENTATION_TAB => Self::Tab,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl StaticType for AutomationBrowsingContextPresentation {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_automation_browsing_context_presentation_get_type()) }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl glib::value::ValueType for AutomationBrowsingContextPresentation {
    type Type = Self;
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
unsafe impl<'a> FromValue<'a> for AutomationBrowsingContextPresentation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl ToValue for AutomationBrowsingContextPresentation {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitAutoplayPolicy")]
pub enum AutoplayPolicy {
    #[doc(alias = "WEBKIT_AUTOPLAY_ALLOW")]
    Allow,
    #[doc(alias = "WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND")]
    AllowWithoutSound,
    #[doc(alias = "WEBKIT_AUTOPLAY_DENY")]
    Deny,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl fmt::Display for AutoplayPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AutoplayPolicy::{}", match *self {
            Self::Allow => "Allow",
            Self::AllowWithoutSound => "AllowWithoutSound",
            Self::Deny => "Deny",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
#[doc(hidden)]
impl IntoGlib for AutoplayPolicy {
    type GlibType = ffi::WebKitAutoplayPolicy;

    fn into_glib(self) -> ffi::WebKitAutoplayPolicy {
        match self {
            Self::Allow => ffi::WEBKIT_AUTOPLAY_ALLOW,
            Self::AllowWithoutSound => ffi::WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND,
            Self::Deny => ffi::WEBKIT_AUTOPLAY_DENY,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitAutoplayPolicy> for AutoplayPolicy {
    unsafe fn from_glib(value: ffi::WebKitAutoplayPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_AUTOPLAY_ALLOW => Self::Allow,
            ffi::WEBKIT_AUTOPLAY_ALLOW_WITHOUT_SOUND => Self::AllowWithoutSound,
            ffi::WEBKIT_AUTOPLAY_DENY => Self::Deny,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl StaticType for AutoplayPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_autoplay_policy_get_type()) }
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl glib::value::ValueType for AutoplayPolicy {
    type Type = Self;
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
unsafe impl<'a> FromValue<'a> for AutoplayPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_30", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_30")))]
impl ToValue for AutoplayPolicy {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCacheModel")]
pub enum CacheModel {
    #[doc(alias = "WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER")]
    DocumentViewer,
    #[doc(alias = "WEBKIT_CACHE_MODEL_WEB_BROWSER")]
    WebBrowser,
    #[doc(alias = "WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER")]
    DocumentBrowser,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CacheModel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CacheModel::{}", match *self {
            Self::DocumentViewer => "DocumentViewer",
            Self::WebBrowser => "WebBrowser",
            Self::DocumentBrowser => "DocumentBrowser",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for CacheModel {
    type GlibType = ffi::WebKitCacheModel;

    fn into_glib(self) -> ffi::WebKitCacheModel {
        match self {
            Self::DocumentViewer => ffi::WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER,
            Self::WebBrowser => ffi::WEBKIT_CACHE_MODEL_WEB_BROWSER,
            Self::DocumentBrowser => ffi::WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCacheModel> for CacheModel {
    unsafe fn from_glib(value: ffi::WebKitCacheModel) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER => Self::DocumentViewer,
            ffi::WEBKIT_CACHE_MODEL_WEB_BROWSER => Self::WebBrowser,
            ffi::WEBKIT_CACHE_MODEL_DOCUMENT_BROWSER => Self::DocumentBrowser,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for CacheModel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_cache_model_get_type()) }
    }
}

impl glib::value::ValueType for CacheModel {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CacheModel {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CacheModel {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitContextMenuAction")]
pub enum ContextMenuAction {
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION")]
    NoAction,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK")]
    OpenLink,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW")]
    OpenLinkInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK")]
    DownloadLinkToDisk,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD")]
    CopyLinkToClipboard,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW")]
    OpenImageInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK")]
    DownloadImageToDisk,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD")]
    CopyImageToClipboard,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW")]
    OpenFrameInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_GO_BACK")]
    GoBack,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD")]
    GoForward,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_STOP")]
    Stop,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_RELOAD")]
    Reload,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY")]
    Copy,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_CUT")]
    Cut,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_PASTE")]
    Paste,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS")]
    SpellingGuess,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND")]
    NoGuessesFound,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING")]
    IgnoreSpelling,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING")]
    LearnSpelling,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR")]
    IgnoreGrammar,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU")]
    FontMenu,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_BOLD")]
    Bold,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_ITALIC")]
    Italic,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE")]
    Underline,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OUTLINE")]
    Outline,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT")]
    InspectElement,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW")]
    OpenVideoInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW")]
    OpenAudioInNewWindow,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD")]
    CopyVideoLinkToClipboard,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD")]
    CopyAudioLinkToClipboard,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS")]
    ToggleMediaControls,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP")]
    ToggleMediaLoop,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN")]
    EnterVideoFullscreen,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY")]
    MediaPlay,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE")]
    MediaPause,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE")]
    MediaMute,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK")]
    DownloadVideoToDisk,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK")]
    DownloadAudioToDisk,
    #[doc(alias = "WEBKIT_CONTEXT_MENU_ACTION_CUSTOM")]
    Custom,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ContextMenuAction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ContextMenuAction::{}", match *self {
            Self::NoAction => "NoAction",
            Self::OpenLink => "OpenLink",
            Self::OpenLinkInNewWindow => "OpenLinkInNewWindow",
            Self::DownloadLinkToDisk => "DownloadLinkToDisk",
            Self::CopyLinkToClipboard => "CopyLinkToClipboard",
            Self::OpenImageInNewWindow => "OpenImageInNewWindow",
            Self::DownloadImageToDisk => "DownloadImageToDisk",
            Self::CopyImageToClipboard => "CopyImageToClipboard",
            Self::OpenFrameInNewWindow => "OpenFrameInNewWindow",
            Self::GoBack => "GoBack",
            Self::GoForward => "GoForward",
            Self::Stop => "Stop",
            Self::Reload => "Reload",
            Self::Copy => "Copy",
            Self::Cut => "Cut",
            Self::Paste => "Paste",
            Self::SpellingGuess => "SpellingGuess",
            Self::NoGuessesFound => "NoGuessesFound",
            Self::IgnoreSpelling => "IgnoreSpelling",
            Self::LearnSpelling => "LearnSpelling",
            Self::IgnoreGrammar => "IgnoreGrammar",
            Self::FontMenu => "FontMenu",
            Self::Bold => "Bold",
            Self::Italic => "Italic",
            Self::Underline => "Underline",
            Self::Outline => "Outline",
            Self::InspectElement => "InspectElement",
            Self::OpenVideoInNewWindow => "OpenVideoInNewWindow",
            Self::OpenAudioInNewWindow => "OpenAudioInNewWindow",
            Self::CopyVideoLinkToClipboard => "CopyVideoLinkToClipboard",
            Self::CopyAudioLinkToClipboard => "CopyAudioLinkToClipboard",
            Self::ToggleMediaControls => "ToggleMediaControls",
            Self::ToggleMediaLoop => "ToggleMediaLoop",
            Self::EnterVideoFullscreen => "EnterVideoFullscreen",
            Self::MediaPlay => "MediaPlay",
            Self::MediaPause => "MediaPause",
            Self::MediaMute => "MediaMute",
            Self::DownloadVideoToDisk => "DownloadVideoToDisk",
            Self::DownloadAudioToDisk => "DownloadAudioToDisk",
            Self::Custom => "Custom",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for ContextMenuAction {
    type GlibType = ffi::WebKitContextMenuAction;

    fn into_glib(self) -> ffi::WebKitContextMenuAction {
        match self {
            Self::NoAction => ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION,
            Self::OpenLink => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK,
            Self::OpenLinkInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW,
            Self::DownloadLinkToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK,
            Self::CopyLinkToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD,
            Self::OpenImageInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW,
            Self::DownloadImageToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK,
            Self::CopyImageToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD,
            Self::OpenFrameInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW,
            Self::GoBack => ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_BACK,
            Self::GoForward => ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD,
            Self::Stop => ffi::WEBKIT_CONTEXT_MENU_ACTION_STOP,
            Self::Reload => ffi::WEBKIT_CONTEXT_MENU_ACTION_RELOAD,
            Self::Copy => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY,
            Self::Cut => ffi::WEBKIT_CONTEXT_MENU_ACTION_CUT,
            Self::Paste => ffi::WEBKIT_CONTEXT_MENU_ACTION_PASTE,
            Self::SpellingGuess => ffi::WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS,
            Self::NoGuessesFound => ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND,
            Self::IgnoreSpelling => ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING,
            Self::LearnSpelling => ffi::WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING,
            Self::IgnoreGrammar => ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR,
            Self::FontMenu => ffi::WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU,
            Self::Bold => ffi::WEBKIT_CONTEXT_MENU_ACTION_BOLD,
            Self::Italic => ffi::WEBKIT_CONTEXT_MENU_ACTION_ITALIC,
            Self::Underline => ffi::WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE,
            Self::Outline => ffi::WEBKIT_CONTEXT_MENU_ACTION_OUTLINE,
            Self::InspectElement => ffi::WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT,
            Self::OpenVideoInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW,
            Self::OpenAudioInNewWindow => ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW,
            Self::CopyVideoLinkToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD,
            Self::CopyAudioLinkToClipboard => ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD,
            Self::ToggleMediaControls => ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS,
            Self::ToggleMediaLoop => ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP,
            Self::EnterVideoFullscreen => ffi::WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN,
            Self::MediaPlay => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY,
            Self::MediaPause => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE,
            Self::MediaMute => ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE,
            Self::DownloadVideoToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK,
            Self::DownloadAudioToDisk => ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK,
            Self::Custom => ffi::WEBKIT_CONTEXT_MENU_ACTION_CUSTOM,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitContextMenuAction> for ContextMenuAction {
    unsafe fn from_glib(value: ffi::WebKitContextMenuAction) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION => Self::NoAction,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK => Self::OpenLink,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_LINK_IN_NEW_WINDOW => Self::OpenLinkInNewWindow,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_LINK_TO_DISK => Self::DownloadLinkToDisk,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_LINK_TO_CLIPBOARD => Self::CopyLinkToClipboard,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_IMAGE_IN_NEW_WINDOW => Self::OpenImageInNewWindow,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_IMAGE_TO_DISK => Self::DownloadImageToDisk,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_IMAGE_TO_CLIPBOARD => Self::CopyImageToClipboard,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_FRAME_IN_NEW_WINDOW => Self::OpenFrameInNewWindow,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_BACK => Self::GoBack,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_GO_FORWARD => Self::GoForward,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_STOP => Self::Stop,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_RELOAD => Self::Reload,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY => Self::Copy,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_CUT => Self::Cut,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_PASTE => Self::Paste,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_SPELLING_GUESS => Self::SpellingGuess,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_NO_GUESSES_FOUND => Self::NoGuessesFound,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_SPELLING => Self::IgnoreSpelling,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_LEARN_SPELLING => Self::LearnSpelling,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_IGNORE_GRAMMAR => Self::IgnoreGrammar,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_FONT_MENU => Self::FontMenu,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_BOLD => Self::Bold,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_ITALIC => Self::Italic,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_UNDERLINE => Self::Underline,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_OUTLINE => Self::Outline,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_INSPECT_ELEMENT => Self::InspectElement,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_VIDEO_IN_NEW_WINDOW => Self::OpenVideoInNewWindow,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_OPEN_AUDIO_IN_NEW_WINDOW => Self::OpenAudioInNewWindow,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_VIDEO_LINK_TO_CLIPBOARD => Self::CopyVideoLinkToClipboard,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_COPY_AUDIO_LINK_TO_CLIPBOARD => Self::CopyAudioLinkToClipboard,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_CONTROLS => Self::ToggleMediaControls,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_TOGGLE_MEDIA_LOOP => Self::ToggleMediaLoop,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_ENTER_VIDEO_FULLSCREEN => Self::EnterVideoFullscreen,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PLAY => Self::MediaPlay,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_PAUSE => Self::MediaPause,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_MEDIA_MUTE => Self::MediaMute,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_VIDEO_TO_DISK => Self::DownloadVideoToDisk,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_DOWNLOAD_AUDIO_TO_DISK => Self::DownloadAudioToDisk,
            ffi::WEBKIT_CONTEXT_MENU_ACTION_CUSTOM => Self::Custom,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for ContextMenuAction {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_context_menu_action_get_type()) }
    }
}

impl glib::value::ValueType for ContextMenuAction {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ContextMenuAction {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ContextMenuAction {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCookieAcceptPolicy")]
pub enum CookieAcceptPolicy {
    #[doc(alias = "WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS")]
    Always,
    #[doc(alias = "WEBKIT_COOKIE_POLICY_ACCEPT_NEVER")]
    Never,
    #[doc(alias = "WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY")]
    NoThirdParty,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CookieAcceptPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CookieAcceptPolicy::{}", match *self {
            Self::Always => "Always",
            Self::Never => "Never",
            Self::NoThirdParty => "NoThirdParty",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for CookieAcceptPolicy {
    type GlibType = ffi::WebKitCookieAcceptPolicy;

    fn into_glib(self) -> ffi::WebKitCookieAcceptPolicy {
        match self {
            Self::Always => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS,
            Self::Never => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NEVER,
            Self::NoThirdParty => ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCookieAcceptPolicy> for CookieAcceptPolicy {
    unsafe fn from_glib(value: ffi::WebKitCookieAcceptPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS => Self::Always,
            ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NEVER => Self::Never,
            ffi::WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY => Self::NoThirdParty,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for CookieAcceptPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_cookie_accept_policy_get_type()) }
    }
}

impl glib::value::ValueType for CookieAcceptPolicy {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CookieAcceptPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CookieAcceptPolicy {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCookiePersistentStorage")]
pub enum CookiePersistentStorage {
    #[doc(alias = "WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT")]
    Text,
    #[doc(alias = "WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE")]
    Sqlite,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CookiePersistentStorage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CookiePersistentStorage::{}", match *self {
            Self::Text => "Text",
            Self::Sqlite => "Sqlite",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for CookiePersistentStorage {
    type GlibType = ffi::WebKitCookiePersistentStorage;

    fn into_glib(self) -> ffi::WebKitCookiePersistentStorage {
        match self {
            Self::Text => ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT,
            Self::Sqlite => ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitCookiePersistentStorage> for CookiePersistentStorage {
    unsafe fn from_glib(value: ffi::WebKitCookiePersistentStorage) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_TEXT => Self::Text,
            ffi::WEBKIT_COOKIE_PERSISTENT_STORAGE_SQLITE => Self::Sqlite,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for CookiePersistentStorage {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_cookie_persistent_storage_get_type()) }
    }
}

impl glib::value::ValueType for CookiePersistentStorage {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for CookiePersistentStorage {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CookiePersistentStorage {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitCredentialPersistence")]
pub enum CredentialPersistence {
    #[doc(alias = "WEBKIT_CREDENTIAL_PERSISTENCE_NONE")]
    None,
    #[doc(alias = "WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION")]
    ForSession,
    #[doc(alias = "WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT")]
    Permanent,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl fmt::Display for CredentialPersistence {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CredentialPersistence::{}", match *self {
            Self::None => "None",
            Self::ForSession => "ForSession",
            Self::Permanent => "Permanent",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl IntoGlib for CredentialPersistence {
    type GlibType = ffi::WebKitCredentialPersistence;

    fn into_glib(self) -> ffi::WebKitCredentialPersistence {
        match self {
            Self::None => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_NONE,
            Self::ForSession => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION,
            Self::Permanent => ffi::WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitCredentialPersistence> for CredentialPersistence {
    unsafe fn from_glib(value: ffi::WebKitCredentialPersistence) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_CREDENTIAL_PERSISTENCE_NONE => Self::None,
            ffi::WEBKIT_CREDENTIAL_PERSISTENCE_FOR_SESSION => Self::ForSession,
            ffi::WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT => Self::Permanent,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl StaticType for CredentialPersistence {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_credential_persistence_get_type()) }
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl glib::value::ValueType for CredentialPersistence {
    type Type = Self;
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
unsafe impl<'a> FromValue<'a> for CredentialPersistence {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_2")))]
impl ToValue for CredentialPersistence {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitInputPurpose")]
pub enum InputPurpose {
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_FREE_FORM")]
    FreeForm,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_DIGITS")]
    Digits,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_NUMBER")]
    Number,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_PHONE")]
    Phone,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_URL")]
    Url,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_EMAIL")]
    Email,
    #[doc(alias = "WEBKIT_INPUT_PURPOSE_PASSWORD")]
    Password,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl fmt::Display for InputPurpose {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "InputPurpose::{}", match *self {
            Self::FreeForm => "FreeForm",
            Self::Digits => "Digits",
            Self::Number => "Number",
            Self::Phone => "Phone",
            Self::Url => "Url",
            Self::Email => "Email",
            Self::Password => "Password",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl IntoGlib for InputPurpose {
    type GlibType = ffi::WebKitInputPurpose;

    fn into_glib(self) -> ffi::WebKitInputPurpose {
        match self {
            Self::FreeForm => ffi::WEBKIT_INPUT_PURPOSE_FREE_FORM,
            Self::Digits => ffi::WEBKIT_INPUT_PURPOSE_DIGITS,
            Self::Number => ffi::WEBKIT_INPUT_PURPOSE_NUMBER,
            Self::Phone => ffi::WEBKIT_INPUT_PURPOSE_PHONE,
            Self::Url => ffi::WEBKIT_INPUT_PURPOSE_URL,
            Self::Email => ffi::WEBKIT_INPUT_PURPOSE_EMAIL,
            Self::Password => ffi::WEBKIT_INPUT_PURPOSE_PASSWORD,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitInputPurpose> for InputPurpose {
    unsafe fn from_glib(value: ffi::WebKitInputPurpose) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_INPUT_PURPOSE_FREE_FORM => Self::FreeForm,
            ffi::WEBKIT_INPUT_PURPOSE_DIGITS => Self::Digits,
            ffi::WEBKIT_INPUT_PURPOSE_NUMBER => Self::Number,
            ffi::WEBKIT_INPUT_PURPOSE_PHONE => Self::Phone,
            ffi::WEBKIT_INPUT_PURPOSE_URL => Self::Url,
            ffi::WEBKIT_INPUT_PURPOSE_EMAIL => Self::Email,
            ffi::WEBKIT_INPUT_PURPOSE_PASSWORD => Self::Password,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl StaticType for InputPurpose {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_input_purpose_get_type()) }
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl glib::value::ValueType for InputPurpose {
    type Type = Self;
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
unsafe impl<'a> FromValue<'a> for InputPurpose {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_28", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_28")))]
impl ToValue for InputPurpose {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitInsecureContentEvent")]
pub enum InsecureContentEvent {
    #[doc(alias = "WEBKIT_INSECURE_CONTENT_RUN")]
    Run,
    #[doc(alias = "WEBKIT_INSECURE_CONTENT_DISPLAYED")]
    Displayed,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for InsecureContentEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "InsecureContentEvent::{}", match *self {
            Self::Run => "Run",
            Self::Displayed => "Displayed",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for InsecureContentEvent {
    type GlibType = ffi::WebKitInsecureContentEvent;

    fn into_glib(self) -> ffi::WebKitInsecureContentEvent {
        match self {
            Self::Run => ffi::WEBKIT_INSECURE_CONTENT_RUN,
            Self::Displayed => ffi::WEBKIT_INSECURE_CONTENT_DISPLAYED,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitInsecureContentEvent> for InsecureContentEvent {
    unsafe fn from_glib(value: ffi::WebKitInsecureContentEvent) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_INSECURE_CONTENT_RUN => Self::Run,
            ffi::WEBKIT_INSECURE_CONTENT_DISPLAYED => Self::Displayed,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for InsecureContentEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_insecure_content_event_get_type()) }
    }
}

impl glib::value::ValueType for InsecureContentEvent {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for InsecureContentEvent {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for InsecureContentEvent {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitLoadEvent")]
pub enum LoadEvent {
    #[doc(alias = "WEBKIT_LOAD_STARTED")]
    Started,
    #[doc(alias = "WEBKIT_LOAD_REDIRECTED")]
    Redirected,
    #[doc(alias = "WEBKIT_LOAD_COMMITTED")]
    Committed,
    #[doc(alias = "WEBKIT_LOAD_FINISHED")]
    Finished,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for LoadEvent {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "LoadEvent::{}", match *self {
            Self::Started => "Started",
            Self::Redirected => "Redirected",
            Self::Committed => "Committed",
            Self::Finished => "Finished",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for LoadEvent {
    type GlibType = ffi::WebKitLoadEvent;

    fn into_glib(self) -> ffi::WebKitLoadEvent {
        match self {
            Self::Started => ffi::WEBKIT_LOAD_STARTED,
            Self::Redirected => ffi::WEBKIT_LOAD_REDIRECTED,
            Self::Committed => ffi::WEBKIT_LOAD_COMMITTED,
            Self::Finished => ffi::WEBKIT_LOAD_FINISHED,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitLoadEvent> for LoadEvent {
    unsafe fn from_glib(value: ffi::WebKitLoadEvent) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_LOAD_STARTED => Self::Started,
            ffi::WEBKIT_LOAD_REDIRECTED => Self::Redirected,
            ffi::WEBKIT_LOAD_COMMITTED => Self::Committed,
            ffi::WEBKIT_LOAD_FINISHED => Self::Finished,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for LoadEvent {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_load_event_get_type()) }
    }
}

impl glib::value::ValueType for LoadEvent {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for LoadEvent {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for LoadEvent {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_34")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitMediaCaptureState")]
pub enum MediaCaptureState {
    #[doc(alias = "WEBKIT_MEDIA_CAPTURE_STATE_NONE")]
    None,
    #[doc(alias = "WEBKIT_MEDIA_CAPTURE_STATE_ACTIVE")]
    Active,
    #[doc(alias = "WEBKIT_MEDIA_CAPTURE_STATE_MUTED")]
    Muted,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_34")))]
impl fmt::Display for MediaCaptureState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "MediaCaptureState::{}", match *self {
            Self::None => "None",
            Self::Active => "Active",
            Self::Muted => "Muted",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_34")))]
#[doc(hidden)]
impl IntoGlib for MediaCaptureState {
    type GlibType = ffi::WebKitMediaCaptureState;

    fn into_glib(self) -> ffi::WebKitMediaCaptureState {
        match self {
            Self::None => ffi::WEBKIT_MEDIA_CAPTURE_STATE_NONE,
            Self::Active => ffi::WEBKIT_MEDIA_CAPTURE_STATE_ACTIVE,
            Self::Muted => ffi::WEBKIT_MEDIA_CAPTURE_STATE_MUTED,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_34")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitMediaCaptureState> for MediaCaptureState {
    unsafe fn from_glib(value: ffi::WebKitMediaCaptureState) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_MEDIA_CAPTURE_STATE_NONE => Self::None,
            ffi::WEBKIT_MEDIA_CAPTURE_STATE_ACTIVE => Self::Active,
            ffi::WEBKIT_MEDIA_CAPTURE_STATE_MUTED => Self::Muted,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_34")))]
impl StaticType for MediaCaptureState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_media_capture_state_get_type()) }
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_34")))]
impl glib::value::ValueType for MediaCaptureState {
    type Type = Self;
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_34")))]
unsafe impl<'a> FromValue<'a> for MediaCaptureState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_34", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_34")))]
impl ToValue for MediaCaptureState {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitNavigationType")]
pub enum NavigationType {
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_LINK_CLICKED")]
    LinkClicked,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED")]
    FormSubmitted,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_BACK_FORWARD")]
    BackForward,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_RELOAD")]
    Reload,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED")]
    FormResubmitted,
    #[doc(alias = "WEBKIT_NAVIGATION_TYPE_OTHER")]
    Other,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NavigationType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "NavigationType::{}", match *self {
            Self::LinkClicked => "LinkClicked",
            Self::FormSubmitted => "FormSubmitted",
            Self::BackForward => "BackForward",
            Self::Reload => "Reload",
            Self::FormResubmitted => "FormResubmitted",
            Self::Other => "Other",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for NavigationType {
    type GlibType = ffi::WebKitNavigationType;

    fn into_glib(self) -> ffi::WebKitNavigationType {
        match self {
            Self::LinkClicked => ffi::WEBKIT_NAVIGATION_TYPE_LINK_CLICKED,
            Self::FormSubmitted => ffi::WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED,
            Self::BackForward => ffi::WEBKIT_NAVIGATION_TYPE_BACK_FORWARD,
            Self::Reload => ffi::WEBKIT_NAVIGATION_TYPE_RELOAD,
            Self::FormResubmitted => ffi::WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED,
            Self::Other => ffi::WEBKIT_NAVIGATION_TYPE_OTHER,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitNavigationType> for NavigationType {
    unsafe fn from_glib(value: ffi::WebKitNavigationType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_NAVIGATION_TYPE_LINK_CLICKED => Self::LinkClicked,
            ffi::WEBKIT_NAVIGATION_TYPE_FORM_SUBMITTED => Self::FormSubmitted,
            ffi::WEBKIT_NAVIGATION_TYPE_BACK_FORWARD => Self::BackForward,
            ffi::WEBKIT_NAVIGATION_TYPE_RELOAD => Self::Reload,
            ffi::WEBKIT_NAVIGATION_TYPE_FORM_RESUBMITTED => Self::FormResubmitted,
            ffi::WEBKIT_NAVIGATION_TYPE_OTHER => Self::Other,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for NavigationType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_navigation_type_get_type()) }
    }
}

impl glib::value::ValueType for NavigationType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for NavigationType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for NavigationType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitNetworkProxyMode")]
pub enum NetworkProxyMode {
    #[doc(alias = "WEBKIT_NETWORK_PROXY_MODE_DEFAULT")]
    Default,
    #[doc(alias = "WEBKIT_NETWORK_PROXY_MODE_NO_PROXY")]
    NoProxy,
    #[doc(alias = "WEBKIT_NETWORK_PROXY_MODE_CUSTOM")]
    Custom,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl fmt::Display for NetworkProxyMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "NetworkProxyMode::{}", match *self {
            Self::Default => "Default",
            Self::NoProxy => "NoProxy",
            Self::Custom => "Custom",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl IntoGlib for NetworkProxyMode {
    type GlibType = ffi::WebKitNetworkProxyMode;

    fn into_glib(self) -> ffi::WebKitNetworkProxyMode {
        match self {
            Self::Default => ffi::WEBKIT_NETWORK_PROXY_MODE_DEFAULT,
            Self::NoProxy => ffi::WEBKIT_NETWORK_PROXY_MODE_NO_PROXY,
            Self::Custom => ffi::WEBKIT_NETWORK_PROXY_MODE_CUSTOM,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitNetworkProxyMode> for NetworkProxyMode {
    unsafe fn from_glib(value: ffi::WebKitNetworkProxyMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_NETWORK_PROXY_MODE_DEFAULT => Self::Default,
            ffi::WEBKIT_NETWORK_PROXY_MODE_NO_PROXY => Self::NoProxy,
            ffi::WEBKIT_NETWORK_PROXY_MODE_CUSTOM => Self::Custom,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl StaticType for NetworkProxyMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_network_proxy_mode_get_type()) }
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl glib::value::ValueType for NetworkProxyMode {
    type Type = Self;
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
unsafe impl<'a> FromValue<'a> for NetworkProxyMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_16", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_16")))]
impl ToValue for NetworkProxyMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitPolicyDecisionType")]
pub enum PolicyDecisionType {
    #[doc(alias = "WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION")]
    NavigationAction,
    #[doc(alias = "WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION")]
    NewWindowAction,
    #[doc(alias = "WEBKIT_POLICY_DECISION_TYPE_RESPONSE")]
    Response,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PolicyDecisionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PolicyDecisionType::{}", match *self {
            Self::NavigationAction => "NavigationAction",
            Self::NewWindowAction => "NewWindowAction",
            Self::Response => "Response",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for PolicyDecisionType {
    type GlibType = ffi::WebKitPolicyDecisionType;

    fn into_glib(self) -> ffi::WebKitPolicyDecisionType {
        match self {
            Self::NavigationAction => ffi::WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION,
            Self::NewWindowAction => ffi::WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION,
            Self::Response => ffi::WEBKIT_POLICY_DECISION_TYPE_RESPONSE,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitPolicyDecisionType> for PolicyDecisionType {
    unsafe fn from_glib(value: ffi::WebKitPolicyDecisionType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION => Self::NavigationAction,
            ffi::WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION => Self::NewWindowAction,
            ffi::WEBKIT_POLICY_DECISION_TYPE_RESPONSE => Self::Response,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for PolicyDecisionType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_policy_decision_type_get_type()) }
    }
}

impl glib::value::ValueType for PolicyDecisionType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PolicyDecisionType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for PolicyDecisionType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitSaveMode")]
pub enum SaveMode {
    #[doc(alias = "WEBKIT_SAVE_MODE_MHTML")]
    Mhtml,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SaveMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SaveMode::{}", match *self {
            Self::Mhtml => "Mhtml",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for SaveMode {
    type GlibType = ffi::WebKitSaveMode;

    fn into_glib(self) -> ffi::WebKitSaveMode {
        match self {
            Self::Mhtml => ffi::WEBKIT_SAVE_MODE_MHTML,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitSaveMode> for SaveMode {
    unsafe fn from_glib(value: ffi::WebKitSaveMode) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_SAVE_MODE_MHTML => Self::Mhtml,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for SaveMode {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_save_mode_get_type()) }
    }
}

impl glib::value::ValueType for SaveMode {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SaveMode {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SaveMode {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitScriptDialogType")]
pub enum ScriptDialogType {
    #[doc(alias = "WEBKIT_SCRIPT_DIALOG_ALERT")]
    Alert,
    #[doc(alias = "WEBKIT_SCRIPT_DIALOG_CONFIRM")]
    Confirm,
    #[doc(alias = "WEBKIT_SCRIPT_DIALOG_PROMPT")]
    Prompt,
    #[doc(alias = "WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM")]
    BeforeUnloadConfirm,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ScriptDialogType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ScriptDialogType::{}", match *self {
            Self::Alert => "Alert",
            Self::Confirm => "Confirm",
            Self::Prompt => "Prompt",
            Self::BeforeUnloadConfirm => "BeforeUnloadConfirm",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for ScriptDialogType {
    type GlibType = ffi::WebKitScriptDialogType;

    fn into_glib(self) -> ffi::WebKitScriptDialogType {
        match self {
            Self::Alert => ffi::WEBKIT_SCRIPT_DIALOG_ALERT,
            Self::Confirm => ffi::WEBKIT_SCRIPT_DIALOG_CONFIRM,
            Self::Prompt => ffi::WEBKIT_SCRIPT_DIALOG_PROMPT,
            Self::BeforeUnloadConfirm => ffi::WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitScriptDialogType> for ScriptDialogType {
    unsafe fn from_glib(value: ffi::WebKitScriptDialogType) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_SCRIPT_DIALOG_ALERT => Self::Alert,
            ffi::WEBKIT_SCRIPT_DIALOG_CONFIRM => Self::Confirm,
            ffi::WEBKIT_SCRIPT_DIALOG_PROMPT => Self::Prompt,
            ffi::WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM => Self::BeforeUnloadConfirm,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for ScriptDialogType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_script_dialog_type_get_type()) }
    }
}

impl glib::value::ValueType for ScriptDialogType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ScriptDialogType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ScriptDialogType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitTLSErrorsPolicy")]
pub enum TLSErrorsPolicy {
    #[doc(alias = "WEBKIT_TLS_ERRORS_POLICY_IGNORE")]
    Ignore,
    #[doc(alias = "WEBKIT_TLS_ERRORS_POLICY_FAIL")]
    Fail,
#[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for TLSErrorsPolicy {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "TLSErrorsPolicy::{}", match *self {
            Self::Ignore => "Ignore",
            Self::Fail => "Fail",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl IntoGlib for TLSErrorsPolicy {
    type GlibType = ffi::WebKitTLSErrorsPolicy;

    fn into_glib(self) -> ffi::WebKitTLSErrorsPolicy {
        match self {
            Self::Ignore => ffi::WEBKIT_TLS_ERRORS_POLICY_IGNORE,
            Self::Fail => ffi::WEBKIT_TLS_ERRORS_POLICY_FAIL,
            Self::__Unknown(value) => value,
}
    }
}

#[doc(hidden)]
impl FromGlib<ffi::WebKitTLSErrorsPolicy> for TLSErrorsPolicy {
    unsafe fn from_glib(value: ffi::WebKitTLSErrorsPolicy) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_TLS_ERRORS_POLICY_IGNORE => Self::Ignore,
            ffi::WEBKIT_TLS_ERRORS_POLICY_FAIL => Self::Fail,
            value => Self::__Unknown(value),
}
    }
}

impl StaticType for TLSErrorsPolicy {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_tls_errors_policy_get_type()) }
    }
}

impl glib::value::ValueType for TLSErrorsPolicy {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for TLSErrorsPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for TLSErrorsPolicy {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserContentInjectedFrames")]
pub enum UserContentInjectedFrames {
    #[doc(alias = "WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES")]
    AllFrames,
    #[doc(alias = "WEBKIT_USER_CONTENT_INJECT_TOP_FRAME")]
    TopFrame,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl fmt::Display for UserContentInjectedFrames {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "UserContentInjectedFrames::{}", match *self {
            Self::AllFrames => "AllFrames",
            Self::TopFrame => "TopFrame",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl IntoGlib for UserContentInjectedFrames {
    type GlibType = ffi::WebKitUserContentInjectedFrames;

    fn into_glib(self) -> ffi::WebKitUserContentInjectedFrames {
        match self {
            Self::AllFrames => ffi::WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES,
            Self::TopFrame => ffi::WEBKIT_USER_CONTENT_INJECT_TOP_FRAME,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserContentInjectedFrames> for UserContentInjectedFrames {
    unsafe fn from_glib(value: ffi::WebKitUserContentInjectedFrames) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_USER_CONTENT_INJECT_ALL_FRAMES => Self::AllFrames,
            ffi::WEBKIT_USER_CONTENT_INJECT_TOP_FRAME => Self::TopFrame,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl StaticType for UserContentInjectedFrames {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_content_injected_frames_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl glib::value::ValueType for UserContentInjectedFrames {
    type Type = Self;
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
unsafe impl<'a> FromValue<'a> for UserContentInjectedFrames {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl ToValue for UserContentInjectedFrames {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserScriptInjectionTime")]
pub enum UserScriptInjectionTime {
    #[doc(alias = "WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START")]
    Start,
    #[doc(alias = "WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END")]
    End,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl fmt::Display for UserScriptInjectionTime {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "UserScriptInjectionTime::{}", match *self {
            Self::Start => "Start",
            Self::End => "End",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl IntoGlib for UserScriptInjectionTime {
    type GlibType = ffi::WebKitUserScriptInjectionTime;

    fn into_glib(self) -> ffi::WebKitUserScriptInjectionTime {
        match self {
            Self::Start => ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START,
            Self::End => ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserScriptInjectionTime> for UserScriptInjectionTime {
    unsafe fn from_glib(value: ffi::WebKitUserScriptInjectionTime) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_START => Self::Start,
            ffi::WEBKIT_USER_SCRIPT_INJECT_AT_DOCUMENT_END => Self::End,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl StaticType for UserScriptInjectionTime {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_script_injection_time_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl glib::value::ValueType for UserScriptInjectionTime {
    type Type = Self;
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
unsafe impl<'a> FromValue<'a> for UserScriptInjectionTime {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl ToValue for UserScriptInjectionTime {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitUserStyleLevel")]
pub enum UserStyleLevel {
    #[doc(alias = "WEBKIT_USER_STYLE_LEVEL_USER")]
    User,
    #[doc(alias = "WEBKIT_USER_STYLE_LEVEL_AUTHOR")]
    Author,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl fmt::Display for UserStyleLevel {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "UserStyleLevel::{}", match *self {
            Self::User => "User",
            Self::Author => "Author",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl IntoGlib for UserStyleLevel {
    type GlibType = ffi::WebKitUserStyleLevel;

    fn into_glib(self) -> ffi::WebKitUserStyleLevel {
        match self {
            Self::User => ffi::WEBKIT_USER_STYLE_LEVEL_USER,
            Self::Author => ffi::WEBKIT_USER_STYLE_LEVEL_AUTHOR,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitUserStyleLevel> for UserStyleLevel {
    unsafe fn from_glib(value: ffi::WebKitUserStyleLevel) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_USER_STYLE_LEVEL_USER => Self::User,
            ffi::WEBKIT_USER_STYLE_LEVEL_AUTHOR => Self::Author,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl StaticType for UserStyleLevel {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_user_style_level_get_type()) }
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl glib::value::ValueType for UserStyleLevel {
    type Type = Self;
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
unsafe impl<'a> FromValue<'a> for UserStyleLevel {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_6", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_6")))]
impl ToValue for UserStyleLevel {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "WebKitWebProcessTerminationReason")]
pub enum WebProcessTerminationReason {
    #[doc(alias = "WEBKIT_WEB_PROCESS_CRASHED")]
    Crashed,
    #[doc(alias = "WEBKIT_WEB_PROCESS_EXCEEDED_MEMORY_LIMIT")]
    ExceededMemoryLimit,
    #[doc(alias = "WEBKIT_WEB_PROCESS_TERMINATED_BY_API")]
    TerminatedByApi,
#[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
impl fmt::Display for WebProcessTerminationReason {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "WebProcessTerminationReason::{}", match *self {
            Self::Crashed => "Crashed",
            Self::ExceededMemoryLimit => "ExceededMemoryLimit",
            Self::TerminatedByApi => "TerminatedByApi",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
#[doc(hidden)]
impl IntoGlib for WebProcessTerminationReason {
    type GlibType = ffi::WebKitWebProcessTerminationReason;

    fn into_glib(self) -> ffi::WebKitWebProcessTerminationReason {
        match self {
            Self::Crashed => ffi::WEBKIT_WEB_PROCESS_CRASHED,
            Self::ExceededMemoryLimit => ffi::WEBKIT_WEB_PROCESS_EXCEEDED_MEMORY_LIMIT,
            Self::TerminatedByApi => ffi::WEBKIT_WEB_PROCESS_TERMINATED_BY_API,
            Self::__Unknown(value) => value,
}
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
#[doc(hidden)]
impl FromGlib<ffi::WebKitWebProcessTerminationReason> for WebProcessTerminationReason {
    unsafe fn from_glib(value: ffi::WebKitWebProcessTerminationReason) -> Self {
        skip_assert_initialized!();
        match value {
            ffi::WEBKIT_WEB_PROCESS_CRASHED => Self::Crashed,
            ffi::WEBKIT_WEB_PROCESS_EXCEEDED_MEMORY_LIMIT => Self::ExceededMemoryLimit,
            ffi::WEBKIT_WEB_PROCESS_TERMINATED_BY_API => Self::TerminatedByApi,
            value => Self::__Unknown(value),
}
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
impl StaticType for WebProcessTerminationReason {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::webkit_web_process_termination_reason_get_type()) }
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
impl glib::value::ValueType for WebProcessTerminationReason {
    type Type = Self;
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
unsafe impl<'a> FromValue<'a> for WebProcessTerminationReason {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

#[cfg(any(feature = "v2_20", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v2_20")))]
impl ToValue for WebProcessTerminationReason {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

